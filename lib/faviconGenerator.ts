import JSZip from 'jszip';

interface FaviconSize {
  name: string;
  width: number;
  height: number;
}

const FAVICON_SIZES: FaviconSize[] = [
  { name: 'favicon-16x16.png', width: 16, height: 16 },
  { name: 'favicon-32x32.png', width: 32, height: 32 },
  { name: 'apple-touch-icon.png', width: 180, height: 180 },
  { name: 'android-chrome-192x192.png', width: 192, height: 192 },
  { name: 'android-chrome-512x512.png', width: 512, height: 512 },
];

const ICO_SIZES = [16, 32, 48];

/**
 * Generates a complete favicon package as a ZIP file
 */
export async function generateFaviconPackage(svgDataUrl: string): Promise<void> {
  const zip = new JSZip();

  // Generate PNG files for each size
  for (const size of FAVICON_SIZES) {
    const pngDataUrl = await renderToPng(svgDataUrl, size.width, size.height);
    const base64Data = pngDataUrl.split(',')[1];
    zip.file(size.name, base64Data, { base64: true });
  }

  // Generate ICO file
  const icoBlob = await generateIco(svgDataUrl, ICO_SIZES);
  zip.file('favicon.ico', icoBlob);

  // Generate site.webmanifest
  const manifest = {
    name: '',
    short_name: '',
    icons: [
      {
        src: '/android-chrome-192x192.png',
        sizes: '192x192',
        type: 'image/png',
      },
      {
        src: '/android-chrome-512x512.png',
        sizes: '512x512',
        type: 'image/png',
      },
    ],
    theme_color: '#ffffff',
    background_color: '#ffffff',
    display: 'standalone',
  };
  zip.file('site.webmanifest', JSON.stringify(manifest, null, 2));

  // Generate HTML snippet
  const htmlSnippet = `<!-- Favicon Package -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<meta name="theme-color" content="#ffffff">`;
  zip.file('favicon-snippet.html', htmlSnippet);

  // Generate README
  const readme = `# Favicon Package

Generated by SVG-Whiz

## Files Included

- \`favicon.ico\` - Multi-size ICO (16x16, 32x32, 48x48)
- \`favicon-16x16.png\` - Standard favicon
- \`favicon-32x32.png\` - High-DPI favicon
- \`apple-touch-icon.png\` - Apple Touch Icon (180x180)
- \`android-chrome-192x192.png\` - Android Chrome icon
- \`android-chrome-512x512.png\` - Android Chrome high-res icon
- \`site.webmanifest\` - Web app manifest
- \`favicon-snippet.html\` - HTML snippet for <head>

## Usage

1. Copy all files to your website's root directory
2. Add the HTML snippet from \`favicon-snippet.html\` to your <head> tag
3. Update the \`site.webmanifest\` with your app name and colors

## HTML Snippet

\`\`\`html
${htmlSnippet}
\`\`\`
`;
  zip.file('README.md', readme);

  // Generate and download ZIP
  const blob = await zip.generateAsync({ type: 'blob' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'favicon-package.zip';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

/**
 * Renders SVG to PNG at specified dimensions
 */
async function renderToPng(svgDataUrl: string, width: number, height: number): Promise<string> {
  return new Promise((resolve, reject) => {
    const img = new Image();

    img.onload = () => {
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;

      const ctx = canvas.getContext('2d');
      if (!ctx) {
        reject(new Error('Could not get canvas context'));
        return;
      }

      ctx.drawImage(img, 0, 0, width, height);
      resolve(canvas.toDataURL('image/png'));
    };

    img.onerror = () => reject(new Error('Failed to load SVG'));
    img.src = svgDataUrl;
  });
}

/**
 * Generates an ICO file from multiple sizes
 */
async function generateIco(svgDataUrl: string, sizes: number[]): Promise<Blob> {
  const pngBuffers: ArrayBuffer[] = [];

  for (const size of sizes) {
    const pngDataUrl = await renderToPng(svgDataUrl, size, size);
    const base64 = pngDataUrl.split(',')[1];
    const binary = atob(base64);
    const buffer = new ArrayBuffer(binary.length);
    const view = new Uint8Array(buffer);
    for (let i = 0; i < binary.length; i++) {
      view[i] = binary.charCodeAt(i);
    }
    pngBuffers.push(buffer);
  }

  return createIcoFile(pngBuffers, sizes);
}

/**
 * Creates an ICO file from PNG buffers
 */
function createIcoFile(pngBuffers: ArrayBuffer[], sizes: number[]): Blob {
  const numImages = pngBuffers.length;
  const headerSize = 6;
  const directoryEntrySize = 16;
  const directorySize = directoryEntrySize * numImages;

  const dataOffset = headerSize + directorySize;
  const totalSize = dataOffset + pngBuffers.reduce((sum, buf) => sum + buf.byteLength, 0);

  const buffer = new ArrayBuffer(totalSize);
  const view = new DataView(buffer);
  const uint8 = new Uint8Array(buffer);

  // ICO Header
  view.setUint16(0, 0, true); // Reserved
  view.setUint16(2, 1, true); // Type (1 = ICO)
  view.setUint16(4, numImages, true); // Count

  // Directory entries
  let currentOffset = dataOffset;
  for (let i = 0; i < numImages; i++) {
    const entryOffset = headerSize + i * directoryEntrySize;
    const size = sizes[i];
    const pngSize = pngBuffers[i].byteLength;

    view.setUint8(entryOffset + 0, size === 256 ? 0 : size);
    view.setUint8(entryOffset + 1, size === 256 ? 0 : size);
    view.setUint8(entryOffset + 2, 0);
    view.setUint8(entryOffset + 3, 0);
    view.setUint16(entryOffset + 4, 1, true);
    view.setUint16(entryOffset + 6, 32, true);
    view.setUint32(entryOffset + 8, pngSize, true);
    view.setUint32(entryOffset + 12, currentOffset, true);

    uint8.set(new Uint8Array(pngBuffers[i]), currentOffset);
    currentOffset += pngSize;
  }

  return new Blob([buffer], { type: 'image/x-icon' });
}
